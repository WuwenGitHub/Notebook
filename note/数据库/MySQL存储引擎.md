<h1>存储引擎类别</h1>MyISAM  InnoDB<h1>简单对比</h1><table>	<tr>		<th></th>		<th>MyISAM</th>		<th>InnoDB</th>	</tr>	<tr>		<td><b>构成上区别</b></td>		<td>每个MyISAM在磁盘上存储为三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型<br>.frm文件：存储表定义<br>.MYD(MYData)文件：数据文件<br>.MYI(MYIndex)文件：索引文件</td>		<td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>	</tr>	<tr>		<td><b>事务处理上</b></td>		<td>MyISAM类型的表强调的是<b>性能</b>，其执行度比InnoDB类型<b>更快</b>，但是<b><em>不提供事务支持</em></b></td>		<td>InnoDB<b><em>支持事务、外部键等高级数据库功能</em></b></td>	</tr>	<tr>		<td><b>SELECT<br>UPDATE<br>INSERT<br>DELETE<b></td>		<td>如果执行大量的SELECT操作，MyISAM是更好的选择</td>		<td><ol>			<li>如果你的数据执行大量的<b>INSERT</b>或<b>UPDATE</b>，出于性能方面的考虑，应该使用InnoDB表</li>			<li><b>DELETE FROM TABLE</b>时，InnoDB不会重新建立表，而是一行一行的删除</li>			<li><b>LOAD TABLE FROM</b>操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用</li>		</ol></td>	</tr>	<tr>		<td><b>对AUTO_INCREMENT的操作</b></td>		<td>每表一个AUTO_INCREMENT的内部处理。<b>MyISAM为INSERT和UPDATE操作自动更新这一列。</b>这使得AUTO_INCREMENT更快(至少10%)。在序列项的值被删除后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况)。<br>AUTO_INCREMENT值可用<b>ALERT TABLE</b>或<b>myisamch</b>来重置<br>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引<br>更好、更快的auto_increament处理</td>		<td>如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为<b>自动增长计数器</b>的计数器，它被用在为该列赋新值。<br>自动增长计数 器仅被存储在<b>主内存</b>中，而不是存在磁盘上<br>关于该计算器 的算法实现，请参考<b>AUTO_INCREMENT列 在InnoDB里 如何工作</b></td>	</tr>	<tr>		<td><b>表的具体行数</b></td>		<td>select count(*) from table,MyISAM只要<b>简单的读出保存好的行数</b>，注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的</td>		<td>InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要<b>扫描一遍整个表</b>来计算有多少行</td>	</tr>	<tr>		<td><b>锁</b></td>		<td><b>表级锁</b></td>		<td>提供<b>行锁(locking on row level)</b>，提供与 Oracle 类型一致的<b>不加锁读取(non-locking read in SELECTs)</b>，另外，InnoDB表的行锁也<b>不是绝对的</b>，如果在执 行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</td>	</tr></table>