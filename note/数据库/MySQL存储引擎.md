<h1>存储引擎类别</h1>MyISAM  InnoDB<h1>简单对比</h1><table>	<tr>		<th></th>		<th>MyISAM</th>		<th>InnoDB</th>	</tr>	<tr>		<td><b>构成上区别</b></td>		<td>每个MyISAM在磁盘上存储为三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型<br>.frm文件：存储表定义<br>.MYD(MYData)文件：数据文件<br>.MYI(MYIndex)文件：索引文件</td>		<td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>	</tr>	<tr>		<td><b>事务处理上</b></td>		<td>MyISAM类型的表强调的是<b>性能</b>，其执行度比InnoDB类型<b>更快</b>，但是<b><em>不提供事务支持</em></b></td>		<td>InnoDB<b><em>支持事务、外部键等高级数据库功能</em></b></td>	</tr>	<tr>		<td><b>SELECT<br>UPDATE<br>INSERT<br>DELETE<b></td>		<td>如果执行大量的SELECT操作，MyISAM是更好的选择</td>		<td><ol>			<li>如果你的数据执行大量的<b>INSERT</b>或<b>UPDATE</b>，出于性能方面的考虑，应该使用InnoDB表</li>			<li><b>DELETE FROM TABLE</b>时，InnoDB不会重新建立表，而是一行一行的删除</li>			<li><b>LOAD TABLE FROM</b>操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用</li>		</ol></td>	</tr>	<tr>		<td><b>对AUTO_INCREMENT的操作</b></td>		<td>每表一个AUTO_INCREMENT的内部处理。<b>MyISAM为INSERT和UPDATE操作自动更新这一列。</b>这使得AUTO_INCREMENT更快(至少10%)。在序列项的值被删除后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况)。<br>AUTO_INCREMENT值可用<b>ALERT TABLE</b>或<b>myisamch</b>来重置<br>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引<br>更好、更快的auto_increament处理</td>		<td>如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为<b>自动增长计数器</b>的计数器，它被用在为该列赋新值。<br>自动增长计数 器仅被存储在<b>主内存</b>中，而不是存在磁盘上<br>关于该计算器 的算法实现，请参考<b>AUTO_INCREMENT列 在InnoDB里 如何工作</b></td>	</tr>	<tr>		<td><b>表的具体行数</b></td>		<td>select count(*) from table,MyISAM只要<b>简单的读出保存好的行数</b>，注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的</td>		<td>InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要<b>扫描一遍整个表</b>来计算有多少行</td>	</tr>	<tr>		<td><b>锁</b></td>		<td><b>表级锁</b></td>		<td>提供<b>行锁(locking on row level)</b>，提供与 Oracle 类型一致的<b>不加锁读取(non-locking read in SELECTs)</b>，另外，InnoDB表的行锁也<b>不是绝对的</b>，如果在执 行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</td>	</tr></table><h1>MySQL存储引擎MyISAM与InnoDB如何选择</h1><h3>两种存储引擎的大致区别：</h3><table border="1">	<tr>		<th></th>		<th>MyISAM</th>		<th>InnoDB</th>	</tr>	<tr>		<td>是否为默认引擎</td>		<td></td>		<td>MySQL 5.5后版本</td>	</tr>	<tr>		<td>事务</td>		<td>不支持</td>		<td>支持</td>	</tr>	<tr>		<td>外键支持</td>		<td>不支持</td>		<td>支持</td>	</tr>	<tr>		<td>表行数保存</td>		<td>保存</td>		<td>不保存</td>	</tr>	<tr>		<td>清空表方式</td>		<td>重建表</td>		<td>一行行删除(效率低)</td>	</tr>	<tr>		<td>FULLTEXT类型的索引</td>		<td></td>		<td>不支持</td>	</tr>	<tr>		<td>应用选择</td>		<td>查询及插入为主应用</td>		<td>频繁修改以及涉及到安全性较高的应用</td>	</tr>	<tr>		<td>锁支持</td>		<td>表级锁</td>		<td>行级锁(在where条件没有使用主键时将锁整张表)</td>	</tr>	<tr>		<td>对自增字段</td>		<td>可以和其他字段建立联合索引</td>		<td>必须包含只有该字段的索引</td>	</tr></table><h3>使用选择</h3><ol>	<li><b>InnoDB</b></li>	<ul>		<li>对<b>事务</b>有较高的需求</li>		<ul>			<li>使用时需要注意InnoDB在where条件没有使用主键时也将锁全表</li>		</ul>		<li>读写密集型</li>	</ul>	<li><b>MyISAM</b></li>	<ul>		<li>对<b>查询性能</b>有较高需求</li>		<ul>			<li>索引、数据分离</li>			<li>索引是压缩的</li>			<li>拥有全文索引功能-->可以极大地优化LIKE查询的效率</li>			<li><b>注：</b>如果数据量较大时需要升级架构</li>		</ul>	</ul></ol><h3>优缺点</h3><table border="1">	<tr>    		<th colspan="2" scope="col" width="300">MyISAM</th>    		<th colspan="2" scope="col" width="300">InnoDB</th> 	</tr>  	<tr>    		<td>优点</td>   		<td>缺点</td>    		<td>优点</td>    		<td>缺点</td>  		</tr>  	<tr>  		<td>  			<ul>  				<li>每个MyISAM在磁盘上存储为三个文件</li>  				<li>MyISAM表可以被压缩，支持全文搜索</li>  				<li>索引、数据分离</li>  				<ul>  					<li>索引是有压缩的-->提高内存使用率-->能加载更多索引</li>  					<li>适合大量的select</li>  				</ul>  				<li>索引缓存于内存中</li>  			</ul>  		</td>  		<td>  			<ul>  				<li>不支持事务</li>  				<li>不支持外键</li>  				<li>不具原子性，回滚将造成不完全回滚</li>  				<li>并发量相对较小-->表级锁</li>  				<ul>  					<li>不适合大量的update</li>  				</ul>  			</ul>  		</td>  		<td>  			<li>数据缓存于内存中</li>  			<li>事务安全</li>  			<li>支持外键</li>  			<li>并发量大</li>  			<li>适合大量的update</li>  		</td>  		<td>  			<li>索引、数据紧密捆绑</li>  			<ul>  				<li>体积庞大<--未使用压缩</li>  				<li>查询速度慢</li>  				<ul>  					<li>AUTOCOMMIT默认打开，且程序没有显式调用BEGIN开始事务，导致每插入一条都自动Commit，严重影响了速度。可以在执行sql前调用begin，多条sql形成一个事务，将大大提高性能</li>  				</ul>  			</ul>  		</td>  	</tr></table>