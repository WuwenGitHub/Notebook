# Mock  ## 一、简介* 模拟一个对象的行为，从而隔离不关心的其他对象，使测试变简单* 可取代真实对象的位置，用于测试一些与真实对象进行交互或依赖于真实对象的行为* 本质：创建一个轻量级的、可控制的对象来代替测试中需要的真实对象* 目的：模拟真实对象的行为和功能## 二、Mock的几种比较## 三、Mockito### 1、简单运用说明* when(mock.someMethod()).thenReturn(value)  * 设定mock对象某个方法调用时的返回值  * 可连续设定返回值：     * when(mock.someMethod()).thenReturn(value1, value2)* when(mock.someMethod()).thenThrow(new RuntimeException())  *  调用方法时抛出异常* 另一种stubbing语法  * doReturn(value).when(mock.someMethod())  * doThrow(new RuntimeException).when(mock.someMethod())* 对void方法进行方法预期设定  * doNothing().when(mock.someMethod())  * doThrow(new RuntimeException()).when(mock.someMethod())  * doNothing().doThrow(new RuntimeException()).when(mock.someMethod())* 参数模拟器  * 方法的参数  * anyInt()     * 传入任何参数为int的方法     * 匹配任何int类型的参数  * anyString()     * 匹配任何字符串  * anySet()     * 匹配任何set* 会自动记录自己的交互行为  * 验证方法Xxx是否按照预期进行了调用     * verify(...).methodXxx(...)     * 验证调用次数        * verify(mock, times(n)).someMethod(argument);           * n为被调用次数，如果超过或少于n多算失败        * times(n)、never()、atLeast(n)、atMost(n)     *  验证超时        * verify(mock, timeout(100)).someMethod();     * 同时验证        *  verify(mock, timeout(100).times(1)).someMethod();### 2、相关注解* MockitoAnnotations.initMocks(this);* ReflectionTestUtils.setField(AopTargetUtils.getTarget(appInfoService), "openAppInfoMapper",openAppInfoMapperMock);* @InjectMocks --- injects mock or spy fields into tested object automatically. ## 三、PowerMock### 1、@PrepareForTest注解* 会修改传入参数类的字节码，通过修改字节码达到模拟final、static、私有方法、静态类等功能* 可写在类上，也可写在方法上```java@PrepareForTest(RemoteServiceImpl.class)```#### 1. mock new 关键字```    //LocalServiceImpl    @Override    public Node getLocalNode(int num, String name) {        return new Node(num, name);    }    /**     * mock new关键字     */    @Test    @PrepareForTest(LocalServiceImpl.class) //PrepareForTest修改local类的字节码以覆盖new的功能    public void testNew() throws Exception {        Node target = new Node(1, "target");        //当传入任意int且name属性为"name"时，new对象返回为target        //当参数条件使用了any系列方法时，剩余的参数都得使用相应的模糊匹配规则，如eq("name")代表参数等于"name"        //剩余还有isNull(), isNotNull(), isA()等方法        PowerMockito.whenNew(Node.class).withArguments(anyInt(), eq("name")).thenReturn(target);        Node result = localService.getLocalNode(2, "name");        assertEquals(target, result); //返回值为target        assertEquals(1, result.getNum());        assertEquals("target", result.getName());        //未指定name为"test"的返回值，默认返回null        Node result2 = localService.getLocalNode(1, "test");        assertNull(result2);    }```##### 2. mock final方法```    //RemoteServiceImpl    @Override    public final Node getFinalNode() {        return new Node(1, "final node");    }    /**     * mock final方法     */    @Test    @PrepareForTest(RemoteServiceImpl.class) //final方法在RemoteServiceImpl类中    public void testFinal() {        Node target = new Node(2, "mock");        PowerMockito.when(remoteService.getFinalNode()).thenReturn(target); //指定返回值        Node result = remoteService.getFinalNode(); //直接调用final方法，返回mock后的值        assertEquals(target, result); //验证返回值        assertEquals(2, result.getNum());        assertEquals("mock", result.getName());    }    ```    ##### 3. mock static 方法    ```        //Node    public static Node getStaticNode() {        return new Node(1, "static node");    }    /**     * mock static方法     */    @Test    @PrepareForTest(Node.class) //static方法定义在Node类中    public void testStatic() {        Node target = new Node(2, "mock");        PowerMockito.mockStatic(Node.class); //mock static方法前需要加这一句        PowerMockito.when(Node.getStaticNode()).thenReturn(target); //指定返回值        Node result = Node.getStaticNode(); //直接调用static方法，返回mock后的值        assertEquals(target, result); //验证返回值        assertEquals(2, result.getNum());        assertEquals("mock", result.getName());    }    ```    ##### 4. mock private 方法    ```        //RemoteServiceImpl    @Override    public Node getPrivateNode() {        return privateMethod();    }    //RemoteServiceImpl    private Node privateMethod() {        return new Node(1, "private node");    }    /**     * mock 私有方法     */    @Test    @PrepareForTest(RemoteServiceImpl.class) //private方法定义在RemoteServiceImpl类中    public void testPrivate() throws Exception {        Node target = new Node(2, "mock");        //按照真实代码调用privateMethod方法        PowerMockito.when(remoteService.getPrivateNode()).thenCallRealMethod();        //私有方法无法访问，类似反射传递方法名和参数，此处无参数故未传        PowerMockito.when(remoteService, "privateMethod").thenReturn(target);        Node result = remoteService.getPrivateNode();        assertEquals(target, result); //验证返回值        assertEquals(2, result.getNum());        assertEquals("mock", result.getName());    }    ```    ##### 5. mock 系统类方法    ```        //RemoteServiceImpl    @Override    public Node getSystemPropertyNode() {        return new Node(System.getProperty("abc"));    }    /**     * mock 系统类方法     */    @Test    @PrepareForTest(RemoteServiceImpl.class) //类似new关键字，系统类方法的调用在类RemoteServiceImpl中，所以这里填的是RemoteServiceImpl    public void testSystem() {        PowerMockito.mockStatic(System.class); //调用的是系统类的静态方法，所以要加这一句        PowerMockito.when(System.getProperty("abc")).thenReturn("mock"); //设置System.getProperty("abc")返回"mock"        PowerMockito.when(remoteService.getSystemPropertyNode()).thenCallRealMethod(); //设置mock对象调用实际方法        Node result = remoteService.getSystemPropertyNode(); //按代码会返回一个name属性为"mock"的对象        assertEquals(0, result.getNum()); //int默认值为0        assertEquals("mock", result.getName()); //remoteService对象中调用System.getProperty("abc")返回的是上面设置的"mock"    }    ```