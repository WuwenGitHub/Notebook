<h1>一、数据类型</h1><ul>	<li>原始数据类型及包装类型</li>	<li>自动装箱、拆箱</li>	<li>缓存</li>	<li>线程安全</li>	<li>原始数据类型数组及对象数组</li></ul><h1>一、数据类型</h1><h4>原始数据类型及包装类型</h4><table border="1">	<tr>		<th>原始数据类型</th>		<th>包装类型</th>	</tr>	<tr>		<td>boolean/1</td>		<td>Boolean</td>	</tr>	<tr>		<td>byte/8</td>		<td>Byte</td>	</tr>	<tr>		<td>char/16</td>		<td>Character</td>	</tr>	<tr>		<td>short/16</td>		<td>Short</td>	</tr>	<tr>		<td>int/32</td>		<td>Integer</td>	</tr>	<tr>		<td>float/32</td>		<td>Float</td>	</tr>	<tr>		<td>long/64</td>		<td>Long</td>	</tr>	<tr>		<td>double/64</td>		<td>Double</td>	</tr></table><h4>自动装箱、拆箱</h4>发生于编译阶段，Java平台为我们自动进行了一些转换，保证不同的写法在运行时等价，生成的字节码是一致的。<br \>装箱操作:Object.valueOf() ==> 将原始数据类型转换为对应的包装类<br \>拆箱操作:Object.objectValue() ==> 将包装类转化为原始数据类型<br \>例：<pre><code>	Integer integer = 1;	int unboxing = integer++;	Boolean boolean1 = true;	boolean unboxing2 = !boolean1;</code></pre>javac替我们自动把装箱转换为Integer.valueOf()、Boolean.valueOf，<br \>把拆箱替换为Integer.intValue()、Boolean.booleanValue().<br \>反编译输出：<pre><code>	.........	1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;	.........	8: invokevirtual #3                  // Method java/lang/Integer.intValue:()I	11: iconst_1	12: iadd	13: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;	16: dup	17: astore_1	18: astore        4	20: aload_3	21: invokevirtual #3                  // Method java/lang/Integer.intValue:()I	24: istore_2	25: iconst_1	26: invokestatic  #4                  // Method java/lang/Boolean.valueOf:(Z)Ljava/lang/Boolean;	29: astore_3	30: aload_3	31: invokevirtual #5                  // Method java/lang/Boolean.booleanValue:()Z	.........</code></pre><h4>包装类型的值缓存</h4>缓存机制：<br \>除Float、Double外，其余基本类型都使用了缓存机制<br \>采用静态数组方式存储：<code>static final Object cache[]</code><br \>当进行自动装箱时，静态工作方法valueOf将会从缓存中去获取值。<br \><pre><code>private static class ObjectCache {        private ObjectCache(){}        static final Object cache[] = new Object[size];        static {            for(int i = 0; i < cache.length; i++)                ......        }    }</code></pre>缓存对象<table border="1">	<tr>		<th>包装类型</th>		<th>缓存对象(基本数据类型值)</th>	</tr>	<tr>		<td>Boolean</td>		<td>true,false</td>	</tr>	<tr>		<td>Byte</td>		<td>-128～127</td>	</tr>	<tr>		<td>Character</td>		<td>'\u0000'～'\u007F'</td>	</tr>	<tr>		<td>Short</td>		<td>-128～127</td>	</tr>	<tr>		<td>Integer</td>		<td>-128～127(默认127，可进行改变)</td>	</tr>	<tr>		<td>Float</td>		<td>无缓存值</td>	</tr>	<tr>		<td>Long</td>		<td>-128～127</td>	</tr>	<tr>		<td>Float</td>		<td>无缓存值</td>	</tr></table>