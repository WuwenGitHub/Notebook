<h1>一、HashMap存储结构</h1>     采用<b>数组</b>+<b>链表</b>+<b>红黑树</b>的方式来存储和组织数据<h1> 二、HashMap中关键数据结构</h1><b>HashMap</b><table>	<tr>		<th>参数名</th>		<th>值</th>	</tr>	<tr>		<td>默认初始化容量</td>		<td><code>DEFAULT_INITIAL_CAPACITY = 1 << 4</code></td>	</tr>	<tr>		<td>最大容量</td>		<td>MAXIMUM_CAPACITY = 1 << 30</td>	</tr>	<tr>		<td>负载因子</td>		<td>DEFAULT_LOAD_FACTOR = 0.75f</td>	</tr>	<tr>		<td>树化阈值</td>		<td>TREEIFY_THRESHOLD = 8</td>	</tr>	<tr>		<td>非树化阈值</td>		<tr>UNTREEIFY_THRESHOLD = 6</tr>	</tr>	<tr>		<td>最低树化容量</td>		<td>MIN_TREEIFY_CAPACITY = 64</td>	</tr></table><pre><code>/** * ... * This implementation provides all of the optional map operations, and permits * <tt>null</tt> values and the <tt>null</tt> key. * ... */public class HashMap<K,V> extends AbstractMap<K,V>    implements Map<K,V>, Cloneable, Serializable {    ...    /**     * The default initial capacity - MUST be a power of two.     */    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16    /**     * The maximum capacity, used if a higher value is implicitly specified     * by either of the constructors with arguments.     * MUST be a power of two <= 1<<30.     */    static final int MAXIMUM_CAPACITY = 1 << 30;    /**     * The load factor used when none specified in constructor.     */    static final float DEFAULT_LOAD_FACTOR = 0.75f;    /**     * The bin count threshold for using a tree rather than list for a     * bin.  Bins are converted to trees when adding an element to a     * bin with at least this many nodes. The value must be greater     * than 2 and should be at least 8 to mesh with assumptions in     * tree removal about conversion back to plain bins upon     * shrinkage.     */    static final int TREEIFY_THRESHOLD = 8;    /**     * The bin count threshold for untreeifying a (split) bin during a     * resize operation. Should be less than TREEIFY_THRESHOLD, and at     * most 6 to mesh with shrinkage detection under removal.     */    static final int UNTREEIFY_THRESHOLD = 6;    /**     * The smallest table capacity for which bins may be treeified.     * (Otherwise the table is resized if too many nodes in a bin.)     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts     * between resizing and treeification thresholds.     */    static final int MIN_TREEIFY_CAPACITY = 64;    ...    /**     * The table, initialized on first use, and resized as     * necessary. When allocated, length is always a power of two.     * (We also tolerate length zero in some operations to allow     * bootstrapping mechanics that are currently not needed.)     */    transient Node<K,V>[] table;    /**     * Holds cached entrySet(). Note that AbstractMap fields are used     * for keySet() and values().     */    transient Set<Map.Entry<K,V>> entrySet;    /**     * The number of key-value mappings contained in this map.     */    transient int size;    /**     * The number of times this HashMap has been structurally modified     * Structural modifications are those that change the number of mappings in     * the HashMap or otherwise modify its internal structure (e.g.,     * rehash).  This field is used to make iterators on Collection-views of     * the HashMap fail-fast.  (See ConcurrentModificationException).     */    transient int modCount;    /**     * The next size value at which to resize (capacity * load factor).     *     * @serial     */    // (The javadoc description is true upon serialization.    // Additionally, if the table array has not been allocated, this    // field holds the initial array capacity, or zero signifying    // DEFAULT_INITIAL_CAPACITY.)    int threshold;    /**     * The load factor for the hash table.     *     * @serial     */    final float loadFactor;    ...}</code></pre><b>Node<K,V></b><pre><code>/** * Basic hash bin node, used for most entries.  (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */static class Node<K,V> implements Map.Entry<K,V> {    final int hash;    final K key;    V value;    Node<K,V> next;    ...}</code></pre><b>红黑树 TreeNode<K,V></b><pre><code>/** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {    TreeNode<K,V> parent;  // red-black tree links    TreeNode<K,V> left;    TreeNode<K,V> right;    TreeNode<K,V> prev;    // needed to unlink next upon deletion    boolean red;    ...}</code></pre><b>HashMap中关于红黑树的三个关键参数</b><table width="200" border="1">    <tr>      <th tabindex="0" scope="col" style="border:1px solid rgb(221,221,221); padding:7px 15px 7px 10px; vertical-align:top; text-align:center; min-width:8px; background:right center no-repeat rgb(240,240,240); color:rgb(51,51,51); max-width:none">      	<p>TREEIFY_THRESHOLD</p>        <pre style="font-family:ConfluenceInstalledFont,monospace"><code>一个桶的树化阈值</code></pre>      </th>      <th tabindex="0" scope="col" style="border:1px solid rgb(221,221,221); padding:7px 15px 7px 10px; vertical-align:top; text-align:center; min-width:8px; background:right center no-repeat rgb(240,240,240); color:rgb(51,51,51); max-width:none">      	<p>UNTREEIFY_THRESHOLD</p>        <pre><code>一个树的链表还原</code></pre>      </th>      <th tabindex="0" scope="col" style="border:1px solid rgb(221,221,221); padding:7px 15px 7px 10px; vertical-align:top; text-align:center; min-width:8px; background:right center no-repeat rgb(240,240,240); color:rgb(51,51,51); max-width:none">      	<p>MIN_TREEIFY_CAPACITY</p>        <pre><code>哈希表的最小树形化容量</code></pre>      </th>    </tr>    <tr>      <td style="border:1px solid rgb(221,221,221); padding:7px 10px; vertical-align:top; text-align:center; min-width:8px">      	<pre style="margin-top:0px; margin-bottom:0px; padding:0px; font-family:ConfluenceInstalledFont,monospace"><code><span class="hljs-keyword">static</span> <span>final</span> <span>int</span> TREEIFY_THRESHOLD = <span>8</span></code></pre>      </td>      <td style="border:1px solid rgb(221,221,221); padding:7px 10px; vertical-align:top; text-align:center; min-width:8px">      	<pre style="margin-top:0px; margin-bottom:0px; padding:0px; font-family:ConfluenceInstalledFont,monospace"><code><span class="hljs-keyword">static</span> <span>final</span> <span>int</span> UNTREEIFY_THRESHOLD = <span>6</span></code></pre>      </td>      <td style="border:1px solid rgb(221,221,221); padding:7px 10px; vertical-align:top; text-align:center; min-width:8px">      	<pre style="margin-top:0px; margin-bottom:0px; padding:0px; font-family:ConfluenceInstalledFont,monospace"><code><span class="hljs-keyword">static</span> <span>final</span> <span>int</span> MIN_TREEIFY_CAPACITY = <span>64</span></code></pre>      </td>    </tr>    <tr>      <td style="border:1px solid rgb(221,221,221); padding:7px 10px; vertical-align:top; text-align:center; min-width:8px">      	<pre style="margin-top:0px; margin-bottom:0px; padding:0px; font-family:ConfluenceInstalledFont,monospace"><code>当桶中元素个数超过这个值时</code></pre><pre style="margin-top:10px; margin-bottom:0px; padding:0px; font-family:ConfluenceInstalledFont,monospace"><code>需要使用红黑树节点替换链表节点</code></pre>      </td>      <td style="border:1px solid rgb(221,221,221); padding:7px 10px; vertical-align:top; text-align:center; min-width:8px">      	<pre style="margin-top:0px; margin-bottom:0px; padding:0px; font-family:ConfluenceInstalledFont,monospace"><code>当扩容时，桶中元素个数小于这个值</code></pre><pre style="margin-top:10px; margin-bottom:0px; padding:0px; font-family:ConfluenceInstalledFont,monospace"><code>就会把树形的桶元素 还原（切分）为链表结构</code></pre>      </td>      <td style="border:1px solid rgb(221,221,221); padding:7px 10px; vertical-align:top; text-align:center; min-width:8px">      	<pre style="margin-top:0px; margin-bottom:0px; padding:0px; font-family:ConfluenceInstalledFont,monospace"><code><ol style="width:593px">        	<li><div>当哈希表中的容量大于这个值时，表中的桶才能进行树形化</div></li>            <li><div><div>否则桶内元素太多时会扩容，而不是树形化</div></div></li>            <li><div><div>为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</div></div></li>        </ol></code></pre>      </td>    </tr>  </table><h1> 三、HashMap类的put方法</h1><b>图解</b><img src="https://github.com/WuwenGitHub/Notebook/blob/master/pics/hashMap put方法执行流程图.png"/><b>方法名</b><pre><code>public V put(K key, V value) {...}</code></pre><b>方法体</b><pre><code>/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with <tt>key</tt>, or *         <tt>null</tt> if there was no mapping for <tt>key</tt>. *         (A <tt>null</tt> return can also indicate that the map *         previously associated <tt>null</tt> with <tt>key</tt>.) */ public V put(K key, V value) {     return putVal(hash(key), key, value, false, true); }</code></pre><b>方法名</b><br /><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {...}</code><br /><b>方法体</b>  <pre><code>/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                boolean evict) {     Node<K,V>[] tab; Node<K,V> p; int n, i;     //判断哈希桶是否为<tt>null</tt>     if ((tab = table) == null || (n = tab.length) == 0)         //重新初始化<tt>table</tt>         n = (tab = resize()).length;     //计算插入位置     //null 存于该节点     //存在 1.节hash值、key值均相同 替换     //     2.该节点为TreeNode 表明为红黑树 连接为TreeNode节点     //     3.按链表方式进行连接     if ((p = tab[i = (n - 1) & hash]) == null)         tab[i] = newNode(hash, key, value, null);     else {         Node<K,V> e; K k;         if (p.hash == hash &&             ((k = p.key) == key || (key != null && key.equals(k))))             e = p;         else if (p instanceof TreeNode)             //插入一TreeNode节点             e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);         else {             for (int binCount = 0; ; ++binCount) {                 if ((e = p.next) == null) {                     p.next = newNode(hash, key, value, null);                     //链表长度超过了8 ,执行树化方法<b>treeifyBin(tab, hash)</b>，                     //但不一定会直接进行树化，若<b>table</b>为<b>null</b>或                     //<b>table</b>长度小于最小树化容量<b>MIN_TREEIFY_CAPACITY=64</b>                     //时，仅仅进行扩容操作，具体详情见<b> treeifyBin(tab, hash)</b>方法                     if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st                         treeifyBin(tab, hash);                     break;                 }                 //如果下一个节点e 不为null 并且这个链表中的节点就是你要找的节点 终止循环                 if (e.hash == hash &&                     ((k = e.key) == key || (key != null && key.equals(k))))                     break;                 p = e;             }         }         //         if (e != null) { // existing mapping for key             V oldValue = e.value;             if (!onlyIfAbsent || oldValue == null)                 e.value = value;             afterNodeAccess(e);             return oldValue;         }     }     ++modCount;     if (++size > threshold)         resize();     afterNodeInsertion(evict);     return null; }</code></pre><b>方法名</b><br /><pre><code>final TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,int h, K k, V v) {...}</code></pre><b>方法体</b><pre><code>/** * Tree version of putVal. * * 当存在hash碰撞的时候，且元素数量大于8个时候，就会以红黑树的方式将这些元素组织起来 * map 当前节点所在的HashMap对象 * tab 当前HashMap对象的元素数组 * h   指定key的hash值 * k   指定key * v   指定key上要写入的值 * 返回：指定key所匹配到的节点对象，针对这个对象去修改V（返回空说明创建了一个新节点） */final TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,                               int h, K k, V v) {    Class<?> kc = null; // 定义k的Class对象    boolean searched = false;// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。    TreeNode<K,V> root = (parent != null) ? root() : this;// 父节点不为空那么查找根节点，为空那么自身就是根节点    for (TreeNode<K,V> p = root;;) {// 从根节点开始遍历，没有终止条件，只能从内部退出        int dir, ph; K pk;// 声明方向、当前节点hash值、当前节点的键对象        if ((ph = p.hash) > h)// 如果当前节点hash 大于 指定key的hash值            dir = -1;// 要添加的元素应该放置在当前节点的左侧        else if (ph < h) // 如果当前节点hash 小于 指定key的hash值            dir = 1;// 要添加的元素应该放置在当前节点的右侧        else if ((pk = p.key) == k || (k != null && k.equals(pk))) // 如果当前节点的键对象 和 指定key对象相同            return p; // 那么就返回当前节点对象，在外层方法会对v进行写入        // 走到这一步说明 当前节点的hash值  和 指定key的hash值  是相等的，但是equals不等        else if ((kc == null &&                  (kc = comparableClassFor(k)) == null) ||                 (dir = compareComparables(kc, k, pk)) == 0) {            // 走到这里说明：指定key没有实现comparable接口 或者 实现comparable接口并且和当前节点的键对象比较之后相等（仅限第一次循环）            /*             * searched 标识是否已经对比过当前节点的左右子节点了             * 如果还没有遍历过，那么就递归遍历对比，看是否能够得到那个键对象equals相等的的节点             * 如果得到了键的equals相等的的节点就返回             * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了             */            if (!searched) { // 如果还没有比对过当前节点的所有子节点                TreeNode<K,V> q, ch; // 定义要返回的节点、和子节点                searched = true; // 标识已经遍历过一次了                /*                 * 红黑树也是二叉树，所以只要沿着左右两侧遍历寻找就可以了                 * 这是个短路运算，如果先从左侧就已经找到了，右侧就不需要遍历了                 * find 方法内部还会有递归调用。参见：find方法解析                 */                if (((ch = p.left) != null &&                     (q = ch.find(h, k, kc)) != null) ||                    ((ch = p.right) != null &&                     (q = ch.find(h, k, kc)) != null))                    return q; // 找到了指定key键对应的            }            // 走到这里就说明，遍历了所有子节点也没有找到和当前键equals相等的节点            dir = tieBreakOrder(k, pk);        }	&nbsp;        TreeNode<K,V> xp = p; // 定义xp指向当前节点        /*         * 如果dir小于等于0，那么看当前节点的左节点是否为空，如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较         * 如果dir大于等于0，那么看当前节点的右节点是否为空，如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较         * 如果以上两条当中有一个子节点不为空，这个if中还做了一件事，那就是把p已经指向了对应的不为空的子节点，开始下一轮的比较         */        if ((p = (dir <= 0) ? p.left : p.right) == null) {	       // 如果恰好要添加的方向上的子节点为空，此时节点p已经指向了这个空的子节点            Node<K,V> xpn = xp.next; // 获取当前节点的next节点            TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn); // 创建一个新的树节点            if (dir <= 0)                 xp.left = x;  // 左孩子指向到这个新的树节点            else                xp.right = x; // 右孩子指向到这个新的树节点            xp.next = x; // 链表中的next节点指向到这个新的树节点            x.parent = x.prev = xp; // 这个新的树节点的父节点、前节点均设置为 当前的树节点            if (xpn != null) // 如果原来的next节点不为空                ((TreeNode<K,V>)xpn).prev = x; // 那么原来的next节点的前节点指向到新的树节点            moveRootToFront(tab, balanceInsertion(root, x)); // 重新平衡，以及新的根节点置顶            return null; // 返回空，意味着产生了一个新节点        }    }}</code></pre><b>方法名</b><pre><code>final void treeifyBin(Node<K,V>[] tab, int hash) {...}</code></pre><b>方法体</b><pre><code>/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */ //将桶内所有的 链表节点 替换成 红黑树节点 final void treeifyBin(Node<K,V>[] tab, int hash) {     int n, index; Node<K,V> e;     //如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)，就去新建/扩容     if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)         resize();     //进行树形化     else if ((e = tab[index = (n - 1) & hash]) != null) {         TreeNode<K,V> hd = null, tl = null;         do {             //将链表节点依次转化为树节点，并连接在一起             TreeNode<K,V> p = replacementTreeNode(e, null);             if (tl == null)                 hd = p;             else {                 p.prev = tl;                 tl.next = p;             }             tl = p;         } while ((e = e.next) != null);         //让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了         if ((tab[index] = hd) != null)             //将 树节点 依 红黑树结构 进行重排列，完全转化为红黑树             hd.treeify(tab);     } }</pre></code><b>方法名</b><pre><code></code>final void treeify(Node<K,V>[] tab) {....}</pre><b>方法体</b><pre><code>/** * Forms tree of the nodes linked from this node. * @return root of tree */ final void treeify(Node<K,V>[] tab) {     TreeNode<K,V> root = null;     for (TreeNode<K,V> x = this, next; x != null; x = next) {         next = (TreeNode<K,V>)x.next;         x.left = x.right = null;         if (root == null) {             x.parent = null;             x.red = false;             root = x;         }         else {             K k = x.key;             int h = x.hash;             Class<?> kc = null;             for (TreeNode<K,V> p = root;;) {                 int dir, ph;                 K pk = p.key;                 if ((ph = p.hash) > h)                     dir = -1;                 else if (ph < h)                     dir = 1;                 else if ((kc == null &&                           (kc = comparableClassFor(k)) == null) ||                          (dir = compareComparables(kc, k, pk)) == 0)                     dir = tieBreakOrder(k, pk);                 TreeNode<K,V> xp = p;                 if ((p = (dir <= 0) ? p.left : p.right) == null) {                     x.parent = xp;                     if (dir <= 0)                         xp.left = x;                     else                          xp.right = x;                     root = balanceInsertion(root, x);                     break;                 }             }         }     }     moveRootToFront(tab, root); }</code></pre>