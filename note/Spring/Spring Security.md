###SecurityContextHolder组件  * 工具类* 静态方法* 保存应用程序中当前使用人的安全上下文* 缺省工作模式**MODE_THREADLOCAL**  * 使用 *ThreadLocal* 机制保存每个使用者的安全上下文（已被 *Spring Security* 自动处理）  * 适合 *Servlet Web* 应用--一个 *Servlet request* 的处理不管经历了多少个 *Filter* ，*自始至终* 都由同一个线程来完成  * 注意：一个 *Servlet request* 的处理不管经历了多少个 *Filter* ，自始至终都由同一个线程来完成;而对于 *同一个使用者* 的 *不同Servlet request* ,它们在服务端被处理时，使用的可 *不一定* 是*同一个*线程(存在由同一个线程处理的可能性但 *不确保* )* 其他工作模式  *  *MODE_GLOBAL*     * 全局策略     * 启动阶段对 *SecurityContextHolder* 配置     * 例：*Java Swing* 客户端应用中，让 *JVM* 中所有线程使用同一个安全上下文  * *MODE_INHERITABLETHREADLOCAL** 修改工作模式方式     * 设置一个系统属性 *spring.security.strategy*     * 调用 *SecurityContextHolder* 静态方法 *setStrategyName()** 当前访问者信息     * 使用 *Authentication* 对象进行表示     * 登陆过程中，由 *Spring Security* 自动创建并保存到 *SecurityContextHolder* 中     * 获取方法 <pre><code>// 获取安全上下文对象，就是那个保存在 ThreadLocal 里面的安全上下文对象// 总是不为null(如果不存在，则创建一个authentication属性为null的empty安全上下文对象)SecurityContext securityContext = SecurityContextHolder.getContext();// 获取当前认证了的 principal(当事人),或者 request token (令牌)// 如果没有认证，会是 null,该例子是认证之后的情况Authentication authentication = securityContext.getAuthentication()// 获取当事人信息对象，返回结果是 Object 类型，但实际上可以是应用程序自定义的带有更多应用相关信息的某个类型。// 很多情况下，该对象是 Spring Security 核心接口 UserDetails 的一个实现类，你可以把 UserDetails 想像// 成我们数据库中保存的一个用户信息到 SecurityContextHolder 中 Spring Security 需要的用户信息格式的// 一个适配器。Object principal = authentication.getPrincipal();if (principal instanceof UserDetails) {	String username = ((UserDetails)principal).getUsername();} else {	String username = principal.toString();}</code></pre>